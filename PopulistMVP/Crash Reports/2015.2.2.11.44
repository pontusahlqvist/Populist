methods that refer to self.context:

getEventFromCoreDataWithId
getContributionFromCoreDataWithId
saveCoreData
createEventWithId
createContributionWithId


methods that call these prior methods
*getEventFromCoreDataWithId:
  - downloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - uploadContributionWithData:andPhoto:
  - handleIncomingDataFromPush:
*getContributionFromCoreDataWithId
  - downloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - downloadContributionMetaDataForEvent:
*saveCoreData
  - sendSignalAndDownloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - downloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - downloadContributionMetaDataForEvent:
  - downloadMediaForContribution:
  - uploadAndSaveContributionInBackground:
  - increaseImportanceOfEvent:By:
  - createEventWithId:
  - createContributionWithId:
*createEventWithId
  - sendSignalAndDownloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - downloadEventMetaDataWithInputLatitude:andLongitude:andDate:
*createContributionWithId
  - downloadEventMetaDataWithInputLatitude:andLongitude:andDate:
  - downloadContributionMetaDataForEvent:
  - uploadContributionWithData:andPhoto:
  - handleIncomingDataFromPush:
  - newDummyTitleContribution:


methods that contain dispatch_async(background queue):
uploadAndSaveContributionInBackground
formatEventCell:ForContribution:
formatJSQMessage:ForContribution:inCollectionView:
chatView - prepareForLoad

1 - modify all methods that refer to self.context to take an NSManagedObjectContext* parameter. Just send along self.context for now.
2 - Iteratively perform this. So, now searching for self.context, we find that it appears in the following locations:

**** sendSignalAndDownloadEventMetaDataWithInputLatitude ****
  - doesn’t define any async call. Must look to see where it is called from. If always from main queue, we can simply send along self.context
    - called from: eventThatUserBelongsTo, exploreVC.finishUpdatingEvents. 
      - finishUpdatingEvents is called from locationUpdatedTo which itself is called from the location manager which is called from the main queue…
      - eventThatUserBelongsTo is called from exploreVC.locationUpdatedTo and chatVC.locationUpdatedTo which are both called from the location manager in the main queue

The conclusion is that sendSignalAndDownloadEventMetaDataWith… is always called on the main thread. No need to do anything except send self.context along. YAY!

**** downloadEventMetaDataWithInputLatitude:andLongitude:andDate: ****
  - doesn’t define any async call. Must look to see where it is called from. 
    -  called from sendSignalAndDownloadEventMetaDataWithInputLatitude: (NOTE: remove from public API!!) Since we established above that this is always called on the main queue, we can without any hesitation just send along self.context. YAY!!
    
**** downloadContributionMetaDataForEvent: ****
  - doesn’t define any async calls so we must look to where it’s called from. This is only called from within chatVC.prepareForLoad. This furthermore always occurs in the background thread. Here we must then deal with the context!! //TODO//

**** downloadMediaForContribution: ****
  - doesn’t setup its own async call. Must then look where it’s called from. 
    - It’s called from formatEventCell, formatJSQMessage. Both of these calls occur in the background thread, so we should deal with these carefully //TODO//
    - I updated the definition of this method to relay the context decision one step earlier. So, no additional work is needed here… yet!?

**** uploadContributionWithData ****
  - doesn’t use async explicitly. Must look for parent calls
    - called from chatVC class. Always from the main queue. No worries then! YAY!!

**** uploadAndSaveContributionInBackground ****
  - defines its own async call. Must use different context here (only on save in last line.)
  - called from uploadContributionWithData in main thread. 

**** handleIncomingDataFromPush ****
  - no new async calls. Also, only called from app delegate. Can safely use self.context YAY!!

**** increaseImportanceOfEvent ****
  - no new async calls. Only called from chatVC on main thread. Good to go!! YAY!!

**** newDummyTitleContribution ****
  - no new async calls. Only called from sendSignalAnd… which we already know is thread safe. So, no worries here either. YAY!!



Issues to resolve:
- this one is called from chatVC in background queue - 
downloadContributionMetaDataForEvent

- these define their own queues -
formatEventCell 
formatJSQMessage
****Comments: I’m guessing that these last two methods can define their own context that they send along and then simply merge the new context with the main context in the following getmainqueue call

uploadAndSaveContributionInBackground
****Comments: This one is tricky. It modifies an object that was originally defined in the main queue once it’s in the background queue.
I think I’ve fixed this one. I pulled out all the data from contribution and placed it in block safe variables __block … Then I return to the main queue at the end to send the push and save core data. Thus I can get away with using self.context.






















	